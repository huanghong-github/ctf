import binascii
import random
import time

import math
from Crypto.Util.number import long_to_bytes, bytes_to_long, isPrime, getPrime
import gmpy2
from gmpy2 import gcd, invert, powmod, iroot, next_prime
from sympy.ntheory import discrete_log, n_order, factorint, primefactors, divisors
from sympy.ntheory.modular import crt
from libnum import n2s, s2n
import sympy
import z3.z3 as z3


## https://zhuanlan.zhihu.com/p/76228394
##################################### e=1
def e1():
    N_hex = 0x180be86dc898a3c3a710e52b31de460f8f350610bf63e6b2203c08fddad44601d96eb454a34dab7684589bc32b19eb27cffff8c07179e349ddb62898ae896f8c681796052ae1598bd41f35491175c9b60ae2260d0d4ebac05b4b6f2677a7609c2fe6194fe7b63841cec632e3a2f55d0cb09df08eacea34394ad473577dea5131552b0b30efac31c59087bfe603d2b13bed7d14967bfd489157aa01b14b4e1bd08d9b92ec0c319aeb8fedd535c56770aac95247d116d59cae2f99c3b51f43093fd39c10f93830c1ece75ee37e5fcdc5b174052eccadcadeda2f1b3a4a87184041d5c1a6a0b2eeaa3c3a1227bc27e130e67ac397b375ffe7c873e9b1c649812edcd
    e_hex = 0x1
    c_hex = 0x4963654354467b66616c6c735f61706172745f736f5f656173696c795f616e645f7265617373656d626c65645f736f5f63727564656c797d
    c_hex = gmpy2.mpz(c_hex)
    N_hex = gmpy2.mpz(N_hex)
    i = 0
    while i < 10:
        m_hex = hex(c_hex + gmpy2.mpz(hex(i)) * N_hex)
        print(m_hex[2:])
        try:
            print(binascii.a2b_hex(m_hex[2:]).decode("utf8"))
        except binascii.Error as e:
            print("位数非偶数，跳过...")
        i += 1


##################################### e=2,3
def e23(c,n=0):
    """
    e=2、3把密文c开平方求解
    由于e只有2、3，相当于把明文m平方而已，得到的c也比n小很多,尝试把c开根号看能否得到明文。
    """
    # c=4153372421328787064168548641845708183921443446990158572506114559735441950501706984118235944441928889749083563790293558028143373121367441549974248211570336802004821051820943229232421937298269855190652251294220483768084460779714162849925877879859830009443131489814222929347727735616113359695228615432020363240247474622132986939108457393618346100033147945959684443762976681454755482192433993286205527003029269574787026484389622816932835184754540312561890719407986296481186847292967270288752616
    m = gmpy2.iroot(c, 2)
    if m[1]:
        m_text = long_to_bytes(m[0])
        print(m_text)
    k = 0
    while True:
        m = gmpy2.iroot(c+k*n, 3)
        k += 1
        if m[1]:
            m_text = long_to_bytes(m[0])
            print(m_text)




def rabin_decrypt(c, p, q, e=2):
    """
    e=2 可能是Rabin加密,Rabin加密中的N可被分解
    """
    n = p * q
    mp = pow(c, (p + 1) / 4, p)
    mq = pow(c, (q + 1) / 4, q)
    yp = gmpy2.invert(p, q)
    yq = gmpy2.invert(q, p)
    r = (yp * p * mq + yq * q * mp) % n
    rr = n - r
    s = (yp * p * mq - yq * q * mp) % n
    ss = n - s
    print(n2s(r))
    print(n2s(rr))
    print(n2s(s))
    print(n2s(ss))


############################# 小明文攻击
def small_e_explode(n, c, e=3):
    """
    e非常小 小明文攻击
    c=m^e mod N
    """
    # N = 27043815113145707550121063378240438939248782258483454049856453521584032220592887787562059443380038610290598575622062916485307184091409554538514854202498873547297773103239316954239641667336894313367845772845023065721439134501310426590019355844524756920078307005324929526063425487642209456355023230208467860774742785099317901398963867106582476740326082746953262216504020111095817613656347722083195076143847189035035063021757574382557663479442190050695927108198420191943271875798380684096592680930644200136436407472778630811000456073548836196890375350827356906953559602627392400524498682642018717447302297325432318177221
    # c = 551046197285606898107283024676650283848098926639864466516013084135553632241090727641369586261735593664613285246299303875854310987447103185795040490541106154790243893699154767869461360532370258323936606948887388561062524928809730633664796872555840144662302473614722601669215346349157307079298093487429776185330734067591880338959687229983724587267427902443245768619370273994981604678382051169765413685049239926816505156737066979728449013908624429525335598674504837548523006533723449926678095026644921098893
    # e = 5
    print(time.asctime())
    for k in range(200000000):
        if gmpy2.iroot(c + n * k, e)[1] == 1:
            res = gmpy2.iroot(c + n * k, e)[0]  # res是m
            print(k, res)
            print(long_to_bytes(res))
            print(time.asctime())
            break


########################################
def rollrsa():
    """
    按行进行解密
    """
    n = 920139713
    p = 49891
    q = 18443
    e = 19
    phi = (p - 1) * (q - 1)
    d = gmpy2.invert(e, phi)
    m = ""
    with open('roll.txt', 'r') as f:
        for c in f.readlines():
            m += long_to_bytes(pow(int(c), d, n))
    print(m)


def same_e(e, n1, c1, n2, c2):
    """
    e n1 n2
    同一个e,且gcd(N1,N2)!=1 也就是N1和N2不互质
    :return:
    """
    p12 = gmpy2.gcd(n1, n2)
    assert (p12 != 1)
    q1 = n1 / p12
    q2 = n2 / p12
    d1 = gmpy2.invert(e, (p12 - 1) * (q1 - 1))
    d2 = gmpy2.invert(e, (p12 - 1) * (q2 - 1))
    m1 = pow(c1, d1, n1)
    m2 = pow(c2, d2, n2)
    print(long_to_bytes(m1) + long_to_bytes(m2))


def same_n(n, e1, c1, e2, c2):
    """共模攻击"""
    # e1 = 0xf4c1158f
    # e2 = 0xf493f7d1
    # n = 0xa1d4d377001f1b8d5b2740514ce699b49dc8a02f12df9a960e80e2a6ee13b7a97d9f508721e3dd7a6842c24ab25ab87d1132358de7c6c4cee3fb3ec9b7fd873626bd0251d16912de1f0f1a2bba52b082339113ad1a262121db31db9ee1bf9f26023182acce8f84612bfeb075803cf610f27b7b16147f7d29cc3fd463df7ea31ca860d59aae5506479c76206603de54044e7b778e21082c4c4da795d39dc2b9c0589e577a773133c89fa8e3a4bd047b8e7d6da0d9a0d8a3c1a3607ce983deb350e1c649725cccb0e9d756fc3107dd4352aa18c45a65bab7772a4c5aef7020a1e67e6085cc125d9fc042d96489a08d885f448ece8f7f254067dfff0c4e72a63557
    # c1 = 12051796366524088489284445109295502686341498426965277230069915294159131976231473789977279364263965099422235647723775278060569378071469131866368399394772898224166518089593340803913798327451963589996734323497943301819051718709807518655868569656941242449109980876397661605271517459716669684900920279597477446629607627693769738733623143693170696779851882404994923673483971528314806130892416509854017091137325195201225617407959645788145876202882024723106204183257094755002924708009138560347432552090905489132135154932987521239299578509008290614398700799670928805692609756924823628055245227290288940649158862576448537833423
    # c2 = 16648382384980770705624348910895797622774711113202207693584907182552301186239613809347201161450012615995859738410661452438496756353485538305614949211776668793864984429696790944750894691957799234264508530084026894611228513698963347402329109838109621609770406925700520983387811451074838470370044678634099202003480925903267508744006195455234025325060817223813858985074720872124168142943926467694676717713503559007112874381750005406371400109962943508349497151148446064846096531445037416174913915923050332242843403926133165817310272633884358263778516770288515592959832151762499526363131801945163501999337808208074381212795
    _, r, s = gmpy2.gcdext(e1, e2)

    m = pow(c1, r, n) * pow(c2, s, n) % n
    print(m)
    print(long_to_bytes(m))


#############################  e特别大,wiener攻击
# rsa-wiener-attack
##################   根据公钥计算得到私钥
# RsaCtfTool
#################   分解n得到相同的几个p
# n==>分解n得到k个p  即n=p**k
def multi_p(n, p, k, e, enc):
    phi = (p ** k) - (p ** k - 1)  # 由欧拉函数得
    d = gmpy2.invert(e, phi)
    m = pow(enc, d, n)
    print(m)


##################   已知n、e、d求p、q,  n一定难以分解得到p和q。
def ned2pq(n, e, d):
    p = 1
    q = 1
    while p == 1 and q == 1:
        k = d * e - 1
        g = random.randint(0, n)
        while p == 1 and q == 1 and k % 2 == 0:
            k /= 2
            y = pow(g, k, n)
            if y != 1 and gmpy2.gcd(y - 1, n) > 1:
                p = gmpy2.gcd(y - 1, n)
                q = n / p
    return p, q


######################## e,n,dp,c
def endpc(e, n, dp, c):
    # e = 65537
    # n = gmpy2.mpz(
    #     248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113)
    # dp = gmpy2.mpz(
    #     905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657)
    #
    # c = gmpy2.mpz(
    #     140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751)

    for x in range(1, e):
        if (e * dp % x == 1):
            p = (e * dp - 1) // x + 1
            if (n % p != 0):
                continue
            q = n // p
            phin = (p - 1) * (q - 1)
            d = gmpy2.invert(e, phin)
            m = gmpy2.powmod(c, d, n)
            if (len(hex(m)[2:]) % 2 == 1):
                continue
            print(long_to_bytes(m))


####################### p,q,dp,dq,c
def pqdpdqc(p, q, dp, dq, c):
    # p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229
    # q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469
    # dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929
    # dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041
    # c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852

    n = p * q
    # phi = (p - 1) * (q - 1)
    dd = gmpy2.gcd(p - 1, q - 1)
    d = (dp - dq) // dd * gmpy2.invert((q - 1) // dd, (p - 1) // dd) * (q - 1) + dq
    print(d)

    m = gmpy2.powmod(c, d, n)
    print(m)
    print(long_to_bytes(m))


####################### 低加密指数广播攻击
# 中国剩余方程
def crtrsa():
    n1 = 86812553978993
    n2 = 81744303091421
    n3 = 83695120256591
    c1 = 8875674977048
    c2 = 70744354709710
    c3 = 29146719498409
    val, _ = crt([n1, n2, n3], [c1, c2, c3])  # 中国剩余方程
    print(val)


####################### 已知p,d,m的部分信息
# 安装sage，CopperSmith定理攻击

"""
from Crypto.PublicKey import RSA

key=RSA.generate(1024)
print hex(key.n),hex(key.e)
#0x907c4c35ef8defb9b0a5bf8ba3f1ad5d0d12ba79cb2913e6ef149a7b62ade6b08fad9618650c3508d8357933f83d1984516af4a1f6236ed734095d88a1c987912bf911d0187184c5182344bfab2203feb24b1f4ef7a94dfa86e5dc68caeead4318e3c043c9b19e1726b27c7948b522f89b5f83f37ea66de0e1ea2af36a38406bL 0x10001

m='*************'
c=power_mod(m,key.e,key.n)
print hex(c)
#0x6bad8e8bc4abe06db93504d120eca56ce6637906d5e2ada9c0010ac706490dfe877e913657ac9105b85ee83ea42c5b6989f067dcb2bacd24daad6679d30f304cda8dcf30509ccf67528ce9373bf469353052042bf1d73ee18e61e7b5eae9914b1619a48fcf48e97f483e50719d346af17e60b4bfd2d9f6ba68a44838db707c1dL

print hex((key.p>>200)<<200)
#0xb6b5afc607cdfb5b103b49b3f83a4fdca35ecf74e259a31b2c22898fe55aaea1ae88ad4be1d6b900000000000000000000000000000000000000000000000000L






load('coppersmith.sage')
n= 0x907c4c35ef8defb9b0a5bf8ba3f1ad5d0d12ba79cb2913e6ef149a7b62ade6b08fad9618650c3508d8357933f83d1984516af4a1f6236ed734095d88a1c987912bf911d0187184c5182344bfab2203feb24b1f4ef7a94dfa86e5dc68caeead4318e3c043c9b19e1726b27c7948b522f89b5f83f37ea66de0e1ea2af36a38406b
e= 0x10001
c= 0x6bad8e8bc4abe06db93504d120eca56ce6637906d5e2ada9c0010ac706490dfe877e913657ac9105b85ee83ea42c5b6989f067dcb2bacd24daad6679d30f304cda8dcf30509ccf67528ce9373bf469353052042bf1d73ee18e61e7b5eae9914b1619a48fcf48e97f483e50719d346af17e60b4bfd2d9f6ba68a44838db707c1d
p_fake=0xb6b5afc607cdfb5b103b49b3f83a4fdca35ecf74e259a31b2c22898fe55aaea1ae88ad4be1d6b900000000000000000000000000000000000000000000000000
pbits= 1024
kbits= 200
pbar = p_fake & (2^pbits-2^kbits)
PR.<x> = PolynomialRing(Zmod(n))
f = x + pbar
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]
print(hex(int(x0 + pbar)))
# p=0xb6b5afc607cdfb5b103b49b3f83a4fdca35ecf74e259a31b2c22898fe55aaea1ae88ad4be1d6b91844b21e08dc6ff7e83858c98a6aa4c3e0d76b716f0c1b5ce1



n= 0x907c4c35ef8defb9b0a5bf8ba3f1ad5d0d12ba79cb2913e6ef149a7b62ade6b08fad9618650c3508d8357933f83d1984516af4a1f6236ed734095d88a1c987912bf911d0187184c5182344bfab2203feb24b1f4ef7a94dfa86e5dc68caeead4318e3c043c9b19e1726b27c7948b522f89b5f83f37ea66de0e1ea2af36a38406b
e= 0x10001
c= 0x6bad8e8bc4abe06db93504d120eca56ce6637906d5e2ada9c0010ac706490dfe877e913657ac9105b85ee83ea42c5b6989f067dcb2bacd24daad6679d30f304cda8dcf30509ccf67528ce9373bf469353052042bf1d73ee18e61e7b5eae9914b1619a48fcf48e97f483e50719d346af17e60b4bfd2d9f6ba68a44838db707c1d
p=0xb6b5afc607cdfb5b103b49b3f83a4fdca35ecf74e259a31b2c22898fe55aaea1ae88ad4be1d6b91844b21e08dc6ff7e83858c98a6aa4c3e0d76b716f0c1b5ce1
q= n//p
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
print(gmpy2.powmod(c, d, n))
print(n2s(1860646442373109105664234426241424519028567088))
"""


####################### N分解出多个不同的因子
def multirsa():
    n = 544187306850902797629107353619267427694837163600853983242783
    e = 39293
    c = 439254895818320413408827022398053685867343267971712332011972
    p1 = 67724172605733871
    p2 = 11571390939636959887
    p3 = 694415063702720454699679
    phi = (p1 - 1) * (p2 - 1) * (p3 - 1)
    d = gmpy2.invert(e, phi)
    m = pow(c, d, n)
    print(long_to_bytes(m))


####################### 已知phi,n
def phin2pq(phi, n):
    x = sympy.Symbol('x')
    # p,q
    p, q = sympy.solve(x ** 2 - (n + 1 - phi) * x + n, [x])
    print(p, q)
######################## 已知qinv,pinv
def pinvqinv():
    """
    qinv * q =1 mod p
    由扩展欧几里得 qinv * q + p * (pinv - q*t)=1
    pinv * p + q * (qinv - p*t)=1

    qinv * q + p * pinv = 1 + p*q*t
    :return:
    """
    e = 65537
    phi = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032
    c = 13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763
    qinv = 63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531
    pinv = 61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507

    p = sympy.symbols('p')
    q = sympy.symbols('q')
    for i in range(10): ## 爆破t
        res = sympy.solve([(p - 1) * (q - 1) - phi, q * qinv + p * pinv - 1 - p * q * i], [p, q])
        print(res)

    x = (
    123234053903541652942120513024032246747867094649170852505205492738250763651515152441072702512040462391199433821952325594964018532743730572667900096661656082321661771850842170948964741662082469784648437838011279609932606565973805550578651338144391008046544927130317796391032212671459108150469414934481805333307,
    127751774511028636140904508602803081004404814196693509362761618618975643854782764452654391767982597130325245855066225266015059151239655830886307663786722512743735360333281875032425179325086788469183594077604962769642166289320247465186662216996075048632956754831703339838339992276387342210477509177054663561573)
    q, p = x
    n = q * p
    d = invert(e, phi)
    print(long_to_bytes(powmod(c, d, n)))

####################### 湖湘杯  p1,p2值接近
def huxiang_rsa(n1, n2):
    """
from Crypto.Util.number import *
from secret import flag
import random

m1 = bytes_to_long(flag[:len(flag) // 2])
m2 = bytes_to_long(flag[len(flag) // 2:])

def gen(pbits, qbits):
    p1, q1 = getPrime(pbits), getPrime(qbits)
    n1 = p1**4*q1
    q2 = getPrime(qbits)
    bound = p1 // (8*q1*q2) + 1
    p2 = random.randrange(p1, p1 + bound)
    while not isPrime(p2):
        p2 = random.randrange(p1, p1 + bound)
    n2 = p2**4*q2
    return (n1, n2), (p1, q1), (p2, q2)

e = 0x10001
pbits = int(360)
qbits = int(128)
pk, sk1, sk2 = gen(pbits, qbits)
c1 = pow(m1, e, pk[0])
c2 = pow(m2, e, pk[1])
print(f'pk = {pk}')
print(f'c1, c2 = {c1, c2}')


pk = (
        1150398070565459492080597718626032792435556703413923483458704675295997646493249759818468321328556510074044954676615760446708253531839417036997811506222349194302791943489195718713797322878586379546657275419261647635859989280700191441312691274285176619391539387875252135478424580680264554294179123254566796890998243909286508189826458854346825493157697201495100628216832191035903848391447704849808577310612723700318670466035077202673373956324725108350230357879374234418393233,
        1242678737076048096780023147702514112272319497423818488193557934695583793070332178723043194823444815153743889740338870676093799728875725651036060313223096288606947708155579060628807516053981975820338028456770109640111153719903207363617099371353910243497871090334898522942934052035102902892149792570965804205461900841595290667647854346905445201396273291648968142608158533514391348407631818144116768794595226974831093526512117505486679153727123796834305088741279455621586989)
    c1, c2 = (
        361624030197288323178211941746074961985876772079713896964822566468795093475887773853629454653096485450671233584616088768705417987527877166166213574572987732852155320225332020636386698169212072312758052524652761304795529199864805108000796457423822443871436659548626629448170698048984709740274043050729249408577243328282313593461300703078854044587993248807613713896590402657788194264718603549894361488507629356532718775278399264279359256975688280723740017979438505001819438,
        33322989148902718763644384246610630825314206644879155585369541624158380990667828419255828083639294898100922608833810585530801931417726134558845725168047585271855248605561256531342703212030641555260907310067120102069499927711242804407691706542428236208695153618955781372741765233319988193384708525251620506966304554054884590718068210659709406626033891748214407992041364462525367373648910810036622684929049996166651416565651803952838857960054689875755131784246099270581394)
    e = 0x10001
    n1,n2=pk[0], pk[1]
    q1,q2=huxiang_rsa(n1,n2)
    p1= gmpy2.iroot(n1 // q1, 4)[0]
    p2 = gmpy2.iroot(n2 // q2, 4)[0]
    phi1=(p1-1)*(q1-1)*p1**3
    phi2=(p2-1)*(q2-1)*p2**3

    d1=invert(e,phi1)
    d2=invert(e,phi2)
    print(long_to_bytes(powmod(c1,d1,n1)))
    print(long_to_bytes(powmod(c2, d2, n2)))
    """

    """
N1/N2=(p1/p2)2 (q1/q2)
显然我们可以知道的是N1/N2 <p1/p2 ; N1/N2<q1/q2
所以在q1/q2在区间(N1/N2,1)之间.
尝试对N1/N2进行连分数展开并求其各项渐进分数,记为ti/si并验证N1%ti==0是否成立,如果成立,那么return.
————————————————
版权声明：本文为CSDN博主「前方是否可导？」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44110537/article/details/108560055
    """

    def Predigest(v):
        child, mother = 0, 1  ## 分子,分母
        for x in v[::-1]:
            child, mother = mother, x * mother + child
        return child, mother

    def GetFra(v):
        for i in range(1, len(v)):
            yield Predigest(v[:i])


    def FraProcessing(a, b):
        v = []
        while b:
            v += [a // b]
            a, b = b, a % b
        return v

    def Slove(n1, n2):
        v = FraProcessing(n1, n2)
        for (child, mother) in GetFra(v):
            if mother and mother != 1 and n1 % mother == 0:
                return mother, child

    return Slove(n1, n2)
### Roal
"""
https://www.cnblogs.com/wayne-tao/p/11723494.html
import sympy
import random
def myGetPrime():
    A= getPrime(513)
    print(A)
    B=A-random.randint(1e3,1e5)
    print(B)
    return sympy.nextPrime((B!)%A)
p=myGetPrime()
#A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
#B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
#p=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140651
q=myGetPrime()
#A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
#B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
#q=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351043
r=myGetPrime()
n=p*q*r
#n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
c=pow(flag,e,n)
#e=0x1001
#c=38347207883249601033653636821391847544875416880619614342339765883967916960100888999916613942668007089161071995631543462301367053958077198225214363505024848543179161424532987598516195302155764378892435582732218546342964613797538210260769612972831286966696915391991999466554505813797987381860855552244138180628982832282918799144636417921948189345110125610972711494191577055380771099863428248761761388282714659239444209955862537018724141881150316760288205511447144
#so,what is the flag?



import sympy
from gmpy2 import *
from Crypto.Util.number import long_to_bytes
A1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467234407
B1=21856963452461630437348278434191434000066076750419027493852463513469865262064340836613831066602300959772632397773487317560339056658299954464169264467140596
A2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858418927
B2=16466113115839228119767887899308820025749260933863446888224167169857612178664139545726340867406790754560227516013796269941438076818194617030304851858351026
n=85492663786275292159831603391083876175149354309327673008716627650718160585639723100793347534649628330416631255660901307533909900431413447524262332232659153047067908693481947121069070451562822417357656432171870951184673132554213690123308042697361969986360375060954702920656364144154145812838558365334172935931441424096270206140691814662318562696925767991937369782627908408239087358033165410020690152067715711112732252038588432896758405898709010342467882264362733
e=4097
c=38347207883249601033653636821391847544875416880619614342339765883967916960100888999916613942668007089161071995631543462301367053958077198225214363505024848543179161424532987598516195302155764378892435582732218546342964613797538210260769612972831286966696915391991999466554505813797987381860855552244138180628982832282918799144636417921948189345110125610972711494191577055380771099863428248761761388282714659239444209955862537018724141881150316760288205511447144
def mod_wei(A,B):
 mod = 1
 x = A-1;
 y = B+1;
 for i in range(y,x):
  mod *= i
  mod %= A
 return mod

x1=mod_wei(A1,B1)
x2=mod_wei(A2,B2)
y1=invert(x1,A1)
y2=invert(x2,A2)
p=sympy.nextprime(y1)
q=sympy.nextprime(y2)
r=n/p/q
o_n=(r-1)*(p-1)*(q-1)
d=invert(e,o_n)

m=pow(c,d,n)
print m
print long_to_bytes(m)
"""
### shendun
"""
https://blog.soreatu.com/posts/writeup-for-easyrsa-in-shendunbei-2019/
"""
### hamburgerRSA
"""
https://ctftime.org/writeup/29693
"""
### BUUCTF
"""
https://happi0.gitee.io/happi0/2020/10/26/BUUCTF-RSA%E5%85%A8%E8%A7%A3/
https://happi0.gitee.io/happi0/2020/10/25/RSA%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/#toc-heading-83
"""
### franklin_reiter
"""
from secret import flag
from Crypto.Util.number import *

m1 = bytes_to_long(flag)
N = getPrime(512)*getPrime(512)
e = 17

c1 = pow(m1, e, N)

a = getRandomNBitInteger(512)
b = getRandomNBitInteger(512)
m2 = a*m1 + b
c2 = pow(m2, e, N)

franklin_reiter.sage
"""
#### nc不互素
"""
m = bytes_to_long(flag)
p = getPrime(1024)
q = getPrime(1024)
n = p * q
print('n =',n)
e = 0x10001
M = 2021 * m * 1001 * p
c = pow(M,e,n)
print('c =',c) 


p = gmpy2.gcd(n, c)
q = n // p 
"""
### p+q+r p*q*r
# https://blog.cryptohack.org/cryptoctf2020
"""
from Crypto.Util.number import *
from secret import flag

def keygen(nbit):
    while True:
        p, q, r = [getPrime(nbit) for _ in range(3)]
        if isPrime(p + q + r):
            pubkey = (p * q * r, p + q + r)
            privkey = (p, q, r)
            return pubkey, privkey

def encrypt(msg, pubkey):
    enc = pow(bytes_to_long(msg.encode('utf-8')), 0x10001, pubkey[0] * pubkey[1])
    return enc

nbit = 512
pubkey, _ = keygen(nbit)
print('pubkey =', pubkey)

enc = encrypt(flag, pubkey)
print('enc =', enc)

p*q*r=763929224901239050077647342425144363318006219360210465113458622937882119766705458273788947718911994090187932947694326848868575500906975653763043489419853300731695950407389203582333794360159494405111004208058198680365172060235321945875374635278292661761319773173838900295933943437761251440819434675631450032782188481758975272071015244168751016874668742536151359822585793537758876078350987062972237271763834743266722655055439868971805843593929839097963319788083763
p+q+r=27750416681837900468631425875797804482827864226099175414717825894823303299159277202974070903630276868248755642608884903122768656427165401563920443482151217

-------------
k0=763929224901239050077647342425144363318006219360210465113458622937882119766705458273788947718911994090187932947694326848868575500906975653763043489419853300731695950407389203582333794360159494405111004208058198680365172060235321945875374635278292661761319773173838900295933943437761251440819434675631450032782188481758975272071015244168751016874668742536151359822585793537758876078350987062972237271763834743266722655055439868971805843593929839097963319788083763
k1=27750416681837900468631425875797804482827864226099175414717825894823303299159277202974070903630276868248755642608884903122768656427165401563920443482151217

e=0x10001
c=7579294603035135817234501131256282324240132424272000903035801073847222917306092792610406876451698121956232047031639448767323475088170357863653435096746640609325525035329328626562143049656124241263576649974820533800161432666946327226418036826146160288273175521864687122720836795596635067761146519940441817765732160382018434465776749372209181212817247187474685246156193381822044772746654690126746715728166527274933634750443478682812664022009444348448955720226579468781927776133336045525149203384137859868153077820708167146052429014790660921586958660759949399826568136755816563468739111123761288318276379025018708883521

d=invert(e,k1-1)
n=k0*k1
print(long_to_bytes(powmod(c, d, k1)))
"""

### same_d
"""
nl = []
el = []
count = 0
while count != 5:
    p = getPrime(512)
    q = getPrime(512)
    n = p * q
    phi = (p - 1) * (q - 1)
    d = gmpy2.next_prime(bytes_to_long(flag))
    e = gmpy2.invert(d, phi)
    nl.append(n)
    el.append(int(e))
    count += 1

print(nl)
print(el)

cl = []
flag = shuffle_flag(flag.decode()).encode()
for i in range(len(nl)):
    cl.append(pow(bytes_to_long(flag), el[i], nl[i]))
print(cl)

same_d.sage
"""

### phi 和 e 不互素
"""
amm.sage
"""

def xortool():
    from z3.z3 import BitVec, Solver, sat
    x = BitVec('x', 278)  # Int('x', 271)
    solver = Solver()
    solver.add(x ^ (x >> 10) == 3037224011445608003714034483008085910653635529573241462739415193515798731471022497)
    if solver.check() == sat:
        result = solver.model()
        for k in result:
            print(k, f"{result[k].as_long():0b}")
    else:
        print("error!")


def test():
    from gmpy2 import gcd, invert, powmod, iroot
    print(gcd(6, 9))  # 最大公因数
    print(invert(5, 7))  # invert(x, m) ,x*y == 1 mod m
    print(discrete_log(41, 15, 7))  # discrete_log(n, a, b) ,b**y mod n =a
    print(factorint(64741))  # 求质因数
    print(primefactors(64741))  # 求质因数
    print(divisors(64))  # 求因数
    print(iroot(4, 2))  # 开方

    p = 101
    q = 641
    c = 32949  # 密文  C ＝ M**E mod N
    n = 64741  # 公共模数 n=p*q
    e = 42667  # 公钥 1< e < (p - 1)*(q - 1)
    d = None  # 私钥 e*d%phi=1
    m = None  # 明文 M ＝C**D mod N
    dp = gmpy2.mod(d, p - 1)
    dq = gmpy2.mod(d, q - 1)
    qinv = gmpy2.invert(q, p)

    phi = (p - 1) * (q - 1)
    n = p*q
    d = invert(e, phi)
    print(long_to_bytes(powmod(c, d, n)))


if __name__ == '__main__':
    n = 96722669749951212913756678234358651184134068407812470434435916603156818917545841439779031943800634250032106764154804309935557678512858630048212204696471487762160744924838010746445510979202735123140536599975731157563069594497905809587369126155476201977830809090473053692189364335223367147692962090288185113654598050169422517553085833257142179937154768657039042632343562454149914801329414293361879935460883633117988279426277638667508115319494914342600199690237441851088350726869553691992122821267990343643644523989413546160765907845604067031798179773495433134648132709349683621175243064236059479837244518879574919017301667066698329442453248971033564328161407342561250703168154214939772631586519304164853651
    c1 = 66738113223447221430009739914948303261002811553064307532926788024694319846909340806982708347904688420671656410554852340732395818007063648478593071665936277836988050526188064146099581039172667768507259894363266310279948729552649788129953872816024709989260060633285022337107662251504618369065597018450927041881262189584381809106166042131798086882746986243210896131714227544235843922107304728228549916171484199199612243776469423359120753888158616202476325705252715374109256790899923317253605743212561589807498078080069511918514647943399566630574192829185904868376879831247378819590121286186417825591746918495311372015707767009078229770450338244309693800180936418605756818618708750868807720566288044943952844
    c2 = 88330949146651042517337653740810385187361689012501792799900873279978736035790659211001047937337215121948527017022967642906632732136313750277237761910710915459733551421653259986088596828049455592613225962133163865584111828012197112528645520371075411167515961263199635568730334149461654340122507778194391601956023625429418297129608911450200836427221311442323768087256798964844787274408624548839536279704401007441198390922847003287643673183230633728790263593607595427088882078742699027563601046309308221108391158848644822374865676056755011459026909057983805069264236657111115914570543103494726584296335044897998794251877515750910330960179539465060133592380802344398038815679281272098815068185059127533110716
    e1 = 49
    e2 = 35
    same_n(n,e1,c1,e2,c2)
 
